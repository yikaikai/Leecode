/*  题目：
    n个数字（0,1,2,...,n）围成一个圆圈，从数字0开始，每次从这个圆圈中删除第m个数字（第一个数字为当前数字本身，第二个为当前数字的下一个数字）。
    当一个数字删除后，从被删除数字的下一个继续删除第m个数字。
    求出在这个圆圈中剩下的最后一个数字。
*/

/*  分析：
    首先定义最初的n个数字（0,1,…,n-1）中最后剩下的数字是关于n和m的方程为f(n,m)。

    在这n个数字中，第一个被删除的数字是=(m-1)%n，那么删除k之后的剩下n-1的数字为0,1,…,k-1,k+1,…,n-1，并且下一个开始计数的数字是k+1。
    相当于在剩下的序列中，k+1排到最前面，从而形成序列k+1,…,n-1,0,…k-1。该序列最后剩下的数字也应该是关于n和m的函数。
    由于这个序列的规律和前面最初的序列不一样（最初的序列是从0开始的连续序列），因此该函数不同于前面函数，记为f’(n-1,m)。
    最初序列最后剩下的数字f(n,m)一定是剩下序列的最后剩下数字f’(n-1,m)，所以f(n,m)=f’(n-1,m)。

    接下来我们把剩下的的这n-1个数字的序列k+1,…,n-1,0,…k-1作一个映射，映射的结果是形成一个从0到n-2的序列：

    k+1    ->    0
    k+2    ->    1
    …
    n-1    ->    n-k-2
    0   ->    n-k-1
    …
    k-1   ->   n-2

    把映射定义为p，则p(x)= (x-k-1)%n，即如果映射前的数字是x，则映射后的数字是(x-k-1)%n。对应的逆映射是p-1(x)=(x+k+1)%n。

    由于映射之后的序列和最初的序列有同样的形式，都是从0开始的连续序列，因此仍然可以用函数f来表示，记为f(n-1,m)。
    根据我们的映射规则，映射之前的序列最后剩下的数字f’(n-1,m)= p-1 [f(n-1,m)]=[f(n-1,m)+k+1]%n。把k=(m-1)%n代入得到   f(n,m)=f’(n-1,m)=[f(n-1,m)+m]%n。

*/

#include<iostream>

using namespace std;

int joseph(int n,int m)
{
    if(n<1 || m<1)
        return -1;
    int leave = 0;
    for(int i = 2;i<=n;++i)
        leave = (leave + m) % i;
    return leave;
}

int main()
{
    cout<<joseph(1000000,1000)<<endl;
    return 0;
}
